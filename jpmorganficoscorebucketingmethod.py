# -*- coding: utf-8 -*-
"""JPMORGANFICOscorebucketingmethod.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14lMl5e8_i1GupFfMiilpwu5xx48w1j2D
"""

import pandas as pd
import numpy as np

file_path = "/content/Task 3 and 4_Loan_Data (2).csv"
df = pd.read_csv(file_path)
print(df.head())

# Keep only required columns
df = df[["fico_score", "default"]]

# Clean data
df = df.dropna()
df["fico_score"] = df["fico_score"].astype(int)
df["default"] = df["default"].astype(int)

df.head()

df = df.sort_values("fico_score").reset_index(drop=True)

fico = df["fico_score"].values
default = df["default"].values
n = len(df)

prefix_defaults = np.cumsum(default)

def bucket_log_likelihood(i, j, prefix_defaults):

    k = prefix_defaults[j] - (prefix_defaults[i-1] if i > 0 else 0)
    n = j - i + 1

    # Avoid log(0)
    if k == 0 or k == n:
        return 0.0

    p = k / n
    return k * np.log(p) + (n - k) * np.log(1 - p)

def optimal_fico_bucketing(default, num_buckets):
    n = len(default)
    prefix_defaults = np.cumsum(default)

    dp = np.full((num_buckets + 1, n), -np.inf)
    split = np.zeros((num_buckets + 1, n), dtype=int)

    # Base case: 1 bucket
    for j in range(n):
        dp[1][j] = bucket_log_likelihood(0, j, prefix_defaults)

    # DP recursion
    for b in range(2, num_buckets + 1):
        for j in range(b - 1, n):
            for i in range(b - 2, j):
                val = dp[b - 1][i] + bucket_log_likelihood(i + 1, j, prefix_defaults)
                if val > dp[b][j]:
                    dp[b][j] = val
                    split[b][j] = i

    return split

def recover_boundaries(split, n, num_buckets):
    boundaries = []
    j = n - 1

    for b in range(num_buckets, 1, -1):
        i = split[b][j]
        boundaries.append(i)
        j = i

    boundaries.reverse()
    return boundaries

def build_rating_map(fico, boundaries):
    cutoffs = [fico[i] for i in boundaries]
    cutoffs = [fico.min()] + cutoffs + [fico.max()]

    rating_map = {}
    rating = 1  # best rating

    for i in range(len(cutoffs) - 1, 0, -1):
        rating_map[rating] = (cutoffs[i-1], cutoffs[i])
        rating += 1

    return rating_map

NUM_BUCKETS = 5

split = optimal_fico_bucketing(default, NUM_BUCKETS)
boundaries = recover_boundaries(split, len(fico), NUM_BUCKETS)
rating_map = build_rating_map(fico, boundaries)

for r, (low, high) in rating_map.items():
    print(f"Rating {r}: FICO {low} â€“ {high}")

def assign_rating(fico_score, rating_map):
    for rating, (low, high) in rating_map.items():
        if low <= fico_score <= high:
            return rating
    return None

df["rating"] = df["fico_score"].apply(lambda x: assign_rating(x, rating_map))
df.head()

summary = (
    df.groupby("rating")
      .agg(
          borrowers=("default", "count"),
          defaults=("default", "sum")
      )
)

summary["pd"] = summary["defaults"] / summary["borrowers"]
summary = summary.sort_index()

summary

